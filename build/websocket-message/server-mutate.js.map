{"version":3,"sources":["websocket-message/server-mutate.js"],"names":[],"mappings":"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","file":"websocket-message/server-mutate.js","sourcesContent":["// WebSocket communications types\n// look doc/server-websocket-message-system.md\nimport {\n  MUTATE,\n  QUERY,\n  ACTION,\n\n  LOGIN_ACCOUNT,\n  REGISTER_ACCOUNT,\n  wsLogAccount,\n  wsGotoPage,\n} from './server-actions'\n\n// Redux server actions\nimport {\n  accountsAdd,\n  accountsUpdate,\n  accountsRemove,\n\n  GROUPS_ADD,\n  GROUPS_REMOVE,\n  GROUPS_ADD_ACCOUNT,\n  GROUPS_REMOVE_ACCOUNT,\n  GROUPS_SELECTED_ACCOUNTS_TO_GROUP,\n  GROUPS_SELECTED_ACCOUNTS_UNASSIGN,\n  GROUPS_ACCOUNTS_UNASSIGN,\n\n  groupsAdd,\n  groupsRemove,\n  groupsAddAccount,\n  groupsRemoveAccount,\n  moveAccounFromGroup,\n} from '../actions/actions'\n\n// Redux client actions\nimport {\n  ACCOUNT_REGISTER_ERROR,\n  ACCOUNT_LOGIN_ERROR,\n} from '../actions/client-actions'\n\n// Default Input fields type and options\nimport { fieldsOptions } from '../config'\n\nimport { createAccount } from '../modules/account/create-account'\nimport { loginAccount } from '../modules/account/login-account'\n\n/**\n * Mutate will process an asynchronous message from a client send by a websocket\n *\n * @param {Object} An object whose values correspond to:\n *                    action: Async action to process\n *                    payload: The info to process\n *                    ws: websocket that trigger the message.\n * @returns {}\n */\n\nexport default async function mutate({ action, payload, ws, store }) {\n  let payloadResponse,\n      result,\n      account\n\n  function reduxStoreServerAndClientRegisterAccountAndGoToWait(account) {\n    let tempAccount\n    // Register the user in the server store.\n    store.dispatch( accountsAdd({...account, group: 'unassigned'}) )\n    console.log('>>>>>state')\n\n    // Log the account in the Client\n    tempAccount = {...account, ws: undefined}\n    delete tempAccount.ws\n    ws.send(  wsLogAccount(account) )\n    console.log('>>>>>state')\n\n    // Go to WaitSync to start session\n    ws.send(\n      wsGotoPage({ url: '/survey/waitSync', options: {} })\n    )\n    console.log('>>>>>state')\n\n  }\n\n  switch (action) {\n    case REGISTER_ACCOUNT:\n      // Register an Account\n      result = await createAccount(\n        {\n          firstName: payload.firstName,\n          surename: payload.surename,\n          email: payload.email,\n          password: payload.password,\n          reEnterPassword: payload.password,\n        },\n        fieldsOptions\n      )\n      if ('message' in result) {\n        // Error try register again.\n        // Send message of error to the client.\n        console.error(result.message)\n        if (\n          result.message === 'The input field email not valid' ||\n          result.message === 'The input field email is not a valid email'\n        ) {\n          payloadResponse = { email: 'The email is not valid' }\n        } else if (\n          result.message === 'The input field password not valid'\n        ) {\n          payloadResponse = { password: 'The password is not valid' }\n        } else if (\n          result.message === 'Email already used.'\n        ) {\n          payloadResponse = { email: 'Please, choose another email.' }\n        }\n        // Send email error\n        ws.send(\n          {\n            type: ACTION,\n            action: ACCOUNT_REGISTER_ERROR,\n            payload: payloadResponse,\n          }\n        )\n        return\n      }\n      // User registered!!\n      //\n      // To give websocket.accountCode the account email\n      // Register the websocket 'ws.accountCode' with the email.\n      // So we can identify the ws with the account email.\n      ws.accountCode = payload.email\n\n      account = {\n        email: payload.email,\n        firstName: payload.firstName,\n        surename: payload.surename,\n        token: result,\n        ws,\n      }\n      reduxStoreServerAndClientRegisterAccountAndGoToWait(account)\n      // Ready to asign to a group\n      return true\n\n    case LOGIN_ACCOUNT:\n      // Login an Account\n      result = await loginAccount({\n        email: payload.email,\n        password: payload.password,\n      })\n      console.log(result)\n\n      if ('message' in result) {\n        // Error try login.\n        // Send message of error to the client.\n        console.error(result.message)\n        if (\n          result.message === 'The input field email not valid' ||\n          result.message === 'The input field email is not a valid email'\n        ) {\n          payloadResponse = { email: 'The email is not valid' }\n        } else if (\n          result.message === 'Password not valid.'\n        ) {\n          payloadResponse = { password: 'The password is not valid' }\n        } else if (\n          result.message === 'Account Email not found.'\n        ) {\n          payloadResponse = { email: 'Please, check email and password.' }\n        }\n        // Send email error\n        ws.send(\n          {\n            type: ACTION,\n            action: ACCOUNT_LOGIN_ERROR,\n            payload: payloadResponse,\n          }\n        )\n        return\n      }\n      // Register the websocket 'ws.accountCode' with the email.\n      // So we can identify the ws with the account email.\n      ws.accountCode = payload.email\n\n      account = {\n        email: payload.email,\n        firstName: result.firstName,\n        surename: result.surename,\n        token: result.token,\n        ws: ws,\n      }\n\n      console.log('>>>>>state')\n      reduxStoreServerAndClientRegisterAccountAndGoToWait(account)\n      console.log('>>>>>state')\n      console.log(store.getState())\n      // console.log('send error login')\n      // console.log(ws.name +' '+ message.type + ' ' + message.payload.email)\n      return true\n\n    case GROUPS_ADD:\n      store.dispatch( groupsAdd( payload.name || Date.now() ) )\n      return true\n\n    case GROUPS_REMOVE:\n      result = store.getState()\n      console.log('>>>>> ' + GROUPS_REMOVE)\n      console.log(payload)\n      console.log(store.getState())\n      console.log('result.accounts[accountId]> ')\n      // console.log(result.accounts[accountId])\n      // Free all the accounts from group\n      result.groups[payload.groupId].map(\n        (accountId) => store.dispatch( accountsUpdate({ ...result.accounts[accountId], group: 'unassigned' }) )\n      )\n      store.dispatch( groupsRemove( payload.groupId ) )\n      return true\n\n    case GROUPS_ADD_ACCOUNT:\n      return true\n\n    case GROUPS_REMOVE_ACCOUNT:\n      return true\n\n    case GROUPS_SELECTED_ACCOUNTS_TO_GROUP:\n      result = store.getState()\n      payload.selected.map(\n        (accountId) => {\n          if ( result.accounts[accountId].group == 'unassigned' ) {\n            store.dispatch( groupsAddAccount( payload.groupId, accountId ) )\n            store.dispatch( accountsUpdate({ ...result.accounts[accountId], group: payload.groupId }) )\n          } else {\n            store.dispatch( moveAccounFromGroup( accountId, payload.groupId ) )\n          }\n        }\n      )\n      return true\n\n    case GROUPS_SELECTED_ACCOUNTS_UNASSIGN:\n      result = store.getState()\n      payload.selected.map(\n        (accountId) => {\n          // remove account from group\n          store.dispatch( groupsRemoveAccount(result.accounts[accountId].group, accountId) )\n          // account to 'unassigned'\n          store.dispatch( accountsUpdate({ ...result.accounts[accountId], group: 'unassigned' }) )\n        }\n      )\n      return true\n\n    case GROUPS_ACCOUNTS_UNASSIGN:\n      result = store.getState()\n      if (result.accounts[payload.accountId]) {\n        // remove account from group\n        store.dispatch( groupsRemoveAccount(result.accounts[payload.accountId].group, payload.accountId) )\n        // account to 'unassigned'\n        store.dispatch( accountsUpdate({ ...result.accounts[payload.accountId], group: 'unassigned' }) )\n      }\n      return true\n\n  }\n}\n"],"sourceRoot":"/source/"}